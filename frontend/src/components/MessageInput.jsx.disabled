import { useRef, useState } from "react";
import { useChatStore } from "../store/useChatStore";
import {
  Image,
  Send,
  X,
  Video,
  Paperclip,
  Mic,
  Square,
  Smile,
} from "lucide-react";
import toast from "react-hot-toast";
import { compressImage, fileToBase64, uploadImage } from "../lib/imageUtils";
import { validateVideoSize, getVideoMetadata } from "../lib/videoUtils";
import {
  VoiceRecorder,
  audioToBase64,
  getAudioDuration,
  formatAudioDuration,
} from "../lib/voiceUtils";

const MessageInput = ({ onSendMessage }) => {
  const [text, setText] = useState("");
  const [imagePreview, setImagePreview] = useState(null);
  const [videoPreview, setVideoPreview] = useState(null);
  const [filePreview, setFilePreview] = useState(null);
  const [audioPreview, setAudioPreview] = useState(null);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState("");
  const [isRecording, setIsRecording] = useState(false);
  const [recordingDuration, setRecordingDuration] = useState(0);
  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
  const fileInputRef = useRef(null);
  const videoInputRef = useRef(null);
  const generalFileInputRef = useRef(null);
  const voiceRecorderRef = useRef(null);
  const recordingTimerRef = useRef(null);
  const { sendMessage } = useChatStore();

  // Emoji picker
  const emojis = [
    "üòÄ",
    "üòÉ",
    "üòÑ",
    "üòÅ",
    "üòÖ",
    "üòÇ",
    "ü§£",
    "üòä",
    "üòá",
    "üôÇ",
    "üôÉ",
    "üòâ",
    "üòå",
    "üòç",
    "ü•∞",
    "üòò",
    "üòó",
    "üòô",
    "üòö",
    "üòã",
    "üòõ",
    "üòù",
    "üòú",
    "ü§™",
    "ü§®",
    "üßê",
    "ü§ì",
    "üòé",
    "ü§©",
    "ü•≥",
    "üòè",
    "üòí",
    "üëç",
    "üëé",
    "üëå",
    "‚úåÔ∏è",
    "ü§û",
    "ü§ü",
    "ü§ò",
    "ü§ô",
    "‚ù§Ô∏è",
    "üß°",
    "üíõ",
    "üíö",
    "üíô",
    "üíú",
    "üñ§",
    "ü§ç",
    "üí•",
    "üí´",
    "üí®",
    "üí§",
    "üíØ",
    "‚ú®",
    "üî•",
    "‚ö°",
  ];

  const addEmoji = (emoji) => {
    setText((prev) => prev + emoji);
    setShowEmojiPicker(false);
  };

  const handleImageChange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (!file.type.startsWith("image/")) {
      toast.error("Please select an image file");
      return;
    }

    try {
      // Compress the image first
      const compressedFile = await compressImage(file);

      // Convert to base64 for immediate preview
      const base64Image = await fileToBase64(compressedFile);
      setImagePreview(base64Image);

      // Upload in background (don't wait for it)
      setIsUploading(true);
      uploadImage(base64Image)
        .then(() => {
          setIsUploading(false);
          // Image uploaded successfully, but we don't need to store URL anymore
        })
        .catch((error) => {
          console.error("Error uploading image:", error);
          toast.error("Failed to upload image");
          setIsUploading(false);
        });
    } catch (error) {
      console.error("Error processing image:", error);
      toast.error("Failed to process image");
    }
  };

  const handleVideoChange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (!file.type.startsWith("video/")) {
      toast.error("Please select a video file");
      return;
    }

    // Validate video size with better messaging
    const sizeValidation = validateVideoSize(file, 100); // Tr·ªü l·∫°i 100MB limit
    if (!sizeValidation.isValid) {
      toast.error(sizeValidation.message);
      return;
    }

    try {
      // Show video metadata
      const metadata = await getVideoMetadata(file);
      toast.success(
        `Video: ${metadata.duration}s, ${metadata.sizeMB}MB, ${metadata.dimensions}`
      );

      // Convert to base64 for immediate preview (limit preview to smaller files)
      if (file.size < 20 * 1024 * 1024) {
        // Only preview if under 20MB
        const base64Video = await fileToBase64(file);
        setVideoPreview(base64Video);
      } else {
        // For large files, just set a placeholder initially
        setVideoPreview("large-video-placeholder");
        toast("Large video - preview disabled for performance", {
          icon: "‚ÑπÔ∏è",
        });
      }

      // Upload in background with processing for large files
      setIsUploading(true);

      // Compress if over 30MB to optimize upload
      if (file.size > 30 * 1024 * 1024) {
        setUploadProgress("Processing large video...");
        toast("Processing large video for faster upload...", {
          icon: "üîÑ",
        });

        // Note: For now, we'll upload original file
        // TODO: Implement proper video compression in future
        setUploadProgress("Uploading large video (please wait)...");
        toast("Uploading large video - this may take a while", {
          icon: "‚è≥",
        });
      } else {
        setUploadProgress("Uploading video...");
      }

      const base64Video = await fileToBase64(file);

      // Update preview with final video
      setVideoPreview(base64Video);
      setIsUploading(false);
      setUploadProgress("");
      toast.success("Video ready to send");

      // Video will be sent via message endpoint when user clicks send
    } catch (error) {
      console.error("Error processing video:", error);
      toast.error("Failed to process video");
      setIsUploading(false);
      setUploadProgress("");
    }
  };

  const handleFileChange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Validate file size (max 50MB for general files)
    if (file.size > 50 * 1024 * 1024) {
      toast.error(
        `File is ${(file.size / 1024 / 1024).toFixed(
          1
        )}MB. Please select a file under 50MB.`
      );
      return;
    }

    try {
      setIsUploading(true);
      setUploadProgress("Processing file...");

      // Show file info
      const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
      toast.success(`File selected: ${file.name} (${fileSizeMB}MB)`);

      // Convert to base64
      const base64File = await fileToBase64(file);

      // Store file info for preview and sending
      setFilePreview({
        data: base64File,
        name: file.name,
        size: file.size,
        type: file.type,
        sizeMB: fileSizeMB,
      });

      setIsUploading(false);
      setUploadProgress("");
      toast.success("File ready to send");
    } catch (error) {
      console.error("Error processing file:", error);
      toast.error("Failed to process file");
      setIsUploading(false);
      setUploadProgress("");
    }
  };

  // Voice recording functions
  const startVoiceRecording = async () => {
    try {
      if (!voiceRecorderRef.current) {
        voiceRecorderRef.current = new VoiceRecorder();
      }

      await voiceRecorderRef.current.startRecording();
      setIsRecording(true);
      setRecordingDuration(0);

      // Start timer
      recordingTimerRef.current = setInterval(() => {
        setRecordingDuration((prev) => prev + 1);
      }, 1000);

      toast.success("Recording started");
    } catch (error) {
      console.error("Error starting recording:", error);
      toast.error(error.message);
    }
  };

  const stopVoiceRecording = async () => {
    try {
      if (!voiceRecorderRef.current || !isRecording) return;

      const audioFile = await voiceRecorderRef.current.stopRecording();

      // Clear timer
      if (recordingTimerRef.current) {
        clearInterval(recordingTimerRef.current);
        recordingTimerRef.current = null;
      }

      setIsRecording(false);

      // Convert to base64 and get duration
      const base64Audio = await audioToBase64(audioFile);
      const duration = await getAudioDuration(audioFile);

      setAudioPreview({
        data: base64Audio,
        duration: duration,
        fileName: audioFile.name,
        size: audioFile.size,
      });

      toast.success(
        `Voice message recorded (${formatAudioDuration(duration)})`
      );
    } catch (error) {
      console.error("Error stopping recording:", error);
      toast.error("Failed to save recording");
      cancelVoiceRecording();
    }
  };

  const cancelVoiceRecording = () => {
    if (voiceRecorderRef.current) {
      voiceRecorderRef.current.cancelRecording();
    }

    if (recordingTimerRef.current) {
      clearInterval(recordingTimerRef.current);
      recordingTimerRef.current = null;
    }

    setIsRecording(false);
    setRecordingDuration(0);
    setAudioPreview(null);
    toast("Recording cancelled");
  };

  const removeImage = () => {
    setImagePreview(null);
    setVideoPreview(null);
    setFilePreview(null);
    setAudioPreview(null);
    setUploadProgress("");
    if (fileInputRef.current) fileInputRef.current.value = "";
    if (videoInputRef.current) videoInputRef.current.value = "";
    if (generalFileInputRef.current) generalFileInputRef.current.value = "";
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (
      !text.trim() &&
      !imagePreview &&
      !videoPreview &&
      !filePreview &&
      !audioPreview
    )
      return;

    const messageData = {
      text: text.trim(),
      image: imagePreview,
      video: videoPreview,
    };

    // Add file data if present
    if (filePreview) {
      messageData.file = filePreview.data;
      messageData.fileName = filePreview.name;
      messageData.fileSize = filePreview.size;
      messageData.fileType = filePreview.type;
    }

    // Add audio data if present
    if (audioPreview) {
      messageData.audio = audioPreview.data;
      messageData.fileName = audioPreview.fileName;
      messageData.fileSize = audioPreview.size;
      messageData.fileType = "audio/webm";
      messageData.audioDuration = audioPreview.duration;
    }

    // Clear form immediately for better UX
    const currentText = text.trim();
    const currentImage = imagePreview;
    const currentVideo = videoPreview;
    const currentFile = filePreview;
    const currentAudio = audioPreview;
    setText("");
    setImagePreview(null);
    setVideoPreview(null);
    setFilePreview(null);
    setAudioPreview(null);
    if (fileInputRef.current) fileInputRef.current.value = "";
    if (videoInputRef.current) videoInputRef.current.value = "";
    if (generalFileInputRef.current) generalFileInputRef.current.value = "";

    try {
      // Send message without waiting for response
      // Use onSendMessage prop if provided (for groups), otherwise use sendMessage from store
      if (onSendMessage) {
        await onSendMessage(messageData);
      } else {
        sendMessage(messageData);
      }
    } catch (error) {
      console.error("Failed to send message:", error);
      // Restore form if error
      setText(currentText);
      setImagePreview(currentImage);
      setVideoPreview(currentVideo);
      setFilePreview(currentFile);
      setAudioPreview(currentAudio);
    }
  };

  return (
    <div className="p-4 w-full">
      {imagePreview && (
        <div className="mb-3 flex items-center gap-2">
          <div className="relative">
            <img
              src={imagePreview}
              alt="Preview"
              className="w-20 h-20 object-cover rounded-lg border border-zinc-700"
            />
            <button
              onClick={removeImage}
              className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
              type="button"
            >
              <X className="size-3" />
            </button>
          </div>
          {isUploading && (
            <div className="text-xs text-gray-400">
              {uploadProgress || "Uploading..."}
            </div>
          )}
        </div>
      )}

      {videoPreview && (
        <div className="mb-3 flex items-center gap-2">
          <div className="relative">
            {videoPreview === "large-video-placeholder" ? (
              <div className="w-20 h-20 bg-gray-700 rounded-lg border border-zinc-700 flex items-center justify-center">
                <Video className="text-blue-400" size={24} />
              </div>
            ) : (
              <video
                src={videoPreview}
                className="w-20 h-20 object-cover rounded-lg border border-zinc-700"
                controls
              />
            )}
            <button
              onClick={removeImage}
              className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
              type="button"
            >
              <X className="size-3" />
            </button>
          </div>
          {isUploading && (
            <div className="text-xs text-gray-400">
              {uploadProgress || "Uploading video..."}
            </div>
          )}
        </div>
      )}

      {audioPreview && (
        <div className="mb-3 flex items-center gap-2">
          <div className="relative">
            <div className="w-32 h-16 bg-green-600 rounded-lg border border-zinc-700 flex flex-col items-center justify-center p-2">
              <div className="text-white text-xs text-center">üé§</div>
              <div className="text-xs text-white text-center">
                Voice {formatAudioDuration(audioPreview.duration)}
              </div>
              <audio
                controls
                className="w-full h-8 mt-1"
                src={audioPreview.data}
                style={{ maxWidth: "120px", height: "24px" }}
              />
            </div>
            <button
              onClick={removeImage}
              className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
              type="button"
            >
              <X className="size-3" />
            </button>
          </div>
        </div>
      )}

      {isRecording && (
        <div className="mb-3 flex items-center gap-2">
          <div className="relative">
            <div className="w-32 h-16 bg-red-600 rounded-lg border border-zinc-700 flex flex-col items-center justify-center p-2 animate-pulse">
              <div className="text-white text-xs text-center">üéôÔ∏è</div>
              <div className="text-xs text-white text-center">
                Recording {formatAudioDuration(recordingDuration)}
              </div>
              <div className="text-xs text-white text-center">
                Click mic to stop
              </div>
            </div>
            <button
              onClick={cancelVoiceRecording}
              className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
              type="button"
            >
              <X className="size-3" />
            </button>
          </div>
        </div>
      )}

      {filePreview && (
        <div className="mb-3 flex items-center gap-2">
          <div className="relative">
            <div className="w-20 h-20 bg-gray-600 rounded-lg border border-zinc-700 flex flex-col items-center justify-center p-2">
              <div className="text-blue-400 text-xs text-center">üìÑ</div>
              <div className="text-xs text-gray-300 text-center truncate w-full">
                {filePreview.name}
              </div>
              <div className="text-xs text-gray-400">
                {filePreview.sizeMB}MB
              </div>
            </div>
            <button
              onClick={removeImage}
              className="absolute -top-1.5 -right-1.5 w-5 h-5 rounded-full bg-base-300
              flex items-center justify-center"
              type="button"
            >
              <X className="size-3" />
            </button>
          </div>
          {isUploading && (
            <div className="text-xs text-gray-400">
              {uploadProgress || "Processing file..."}
            </div>
          )}
        </div>
      )}

      <form onSubmit={handleSendMessage} className="flex items-center gap-2">
        <div className="flex-1 flex gap-2 relative">
          <input
            type="text"
            className="w-full input input-bordered rounded-lg input-sm sm:input-md"
            placeholder="Type a message..."
            value={text}
            onChange={(e) => setText(e.target.value)}
          />

          {/* Emoji Picker */}
          {showEmojiPicker && (
            <div className="absolute bottom-12 left-0 bg-base-100 border border-base-300 rounded-lg p-2 shadow-lg z-10 w-64">
              <div className="grid grid-cols-8 gap-1 max-h-32 overflow-y-auto">
                {emojis.map((emoji, index) => (
                  <button
                    key={index}
                    type="button"
                    className="p-1 hover:bg-base-200 rounded text-lg"
                    onClick={() => addEmoji(emoji)}
                  >
                    {emoji}
                  </button>
                ))}
              </div>
            </div>
          )}

          {/* Emoji Button */}
          <button
            type="button"
            className="btn btn-circle btn-sm sm:btn-md text-zinc-400 hover:text-yellow-500"
            onClick={() => setShowEmojiPicker(!showEmojiPicker)}
          >
            <Smile size={20} />
          </button>

          <input
            type="file"
            accept="image/*"
            className="hidden"
            ref={fileInputRef}
            onChange={handleImageChange}
          />
          <input
            type="file"
            accept="video/*"
            className="hidden"
            ref={videoInputRef}
            onChange={handleVideoChange}
          />
          <input
            type="file"
            className="hidden"
            ref={generalFileInputRef}
            onChange={handleFileChange}
          />

          <button
            type="button"
            className={`hidden sm:flex btn btn-circle
                     ${imagePreview ? "text-emerald-500" : "text-zinc-400"}`}
            onClick={() => fileInputRef.current?.click()}
          >
            <Image size={20} />
          </button>

          <button
            type="button"
            className={`hidden sm:flex btn btn-circle
                     ${videoPreview ? "text-blue-500" : "text-zinc-400"}`}
            onClick={() => videoInputRef.current?.click()}
          >
            <Video size={20} />
          </button>

          <button
            type="button"
            className={`hidden sm:flex btn btn-circle
                     ${filePreview ? "text-purple-500" : "text-zinc-400"}`}
            onClick={() => generalFileInputRef.current?.click()}
          >
            <Paperclip size={20} />
          </button>

          <button
            type="button"
            className={`hidden sm:flex btn btn-circle
                     ${
                       isRecording
                         ? "text-red-500 animate-pulse"
                         : audioPreview
                         ? "text-green-500"
                         : "text-zinc-400"
                     }`}
            onClick={isRecording ? stopVoiceRecording : startVoiceRecording}
            disabled={isUploading}
          >
            {isRecording ? <Square size={20} /> : <Mic size={20} />}
          </button>
        </div>
        <button
          type="submit"
          className="btn btn-sm btn-circle"
          disabled={
            (!text.trim() &&
              !imagePreview &&
              !videoPreview &&
              !filePreview &&
              !audioPreview) ||
            isUploading ||
            isRecording
          }
        >
          <Send size={22} />
        </button>
      </form>
    </div>
  );
};
export default MessageInput;
